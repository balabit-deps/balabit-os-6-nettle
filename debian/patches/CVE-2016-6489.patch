Description: fix RSA cache timing side-channel attack
Origin: upstream, https://git.lysator.liu.se/nettle/nettle/commit/3fe1d6549765ecfb24f0b80b2ed086fdc818bff3
Origin: upstream, https://git.lysator.liu.se/nettle/nettle/commit/5eb30d94f6f5f3f0cb9ba9ed24bc52b7376176b6
Origin: upstream, https://git.lysator.liu.se/nettle/nettle/commit/52b9223126b3f997c00d399166c006ae28669068
Origin: upstream, https://git.lysator.liu.se/nettle/nettle/commit/544b4047de689519ab3e6ec55b776b95b3e264a9
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=832983

Index: nettle-3.2/bignum.h
===================================================================
--- nettle-3.2.orig/bignum.h	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/bignum.h	2017-02-03 08:16:04.274825648 -0500
@@ -53,6 +53,8 @@
 # define mpz_combit mpz_combit
 # define mpz_import mpz_import
 # define mpz_export mpz_export
+/* Side-channel silent powm not available in mini-gmp. */
+# define mpz_powm_sec mpz_pwm
 #else
 # include <gmp.h>
 #endif
Index: nettle-3.2/configure.ac
===================================================================
--- nettle-3.2.orig/configure.ac	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/configure.ac	2017-02-03 08:16:04.274825648 -0500
@@ -236,9 +236,9 @@
 # Checks for libraries
 if test "x$enable_public_key" = "xyes" ; then
   if test "x$enable_mini_gmp" = "xno" ; then
-    AC_CHECK_LIB(gmp, __gmpz_getlimbn,,
+    AC_CHECK_LIB(gmp, __gmpz_mpz_powm,,
         [AC_MSG_WARN(
-    [GNU MP not found, or not 3.1 or up, see http://gmplib.org/.
+    [GNU MP not found, or too old. GMP-5.0 or later is needed, see http://gmplib.org/.
     Support for public key algorithms will be unavailable.])]
         enable_public_key=no)
 
Index: nettle-3.2/dsa-sign.c
===================================================================
--- nettle-3.2.orig/dsa-sign.c	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/dsa-sign.c	2017-02-03 08:16:11.322910929 -0500
@@ -56,6 +56,11 @@
   mpz_t tmp;
   int res;
   
+  /* Check that p is odd, so that invalid keys don't result in a crash
+     inside mpz_powm_sec. */
+  if (mpz_even_p (params->p))
+    return 0;
+
   /* Select k, 0<k<q, randomly */
   mpz_init_set(tmp, params->q);
   mpz_sub_ui(tmp, tmp, 1);
@@ -65,7 +70,7 @@
   mpz_add_ui(k, k, 1);
 
   /* Compute r = (g^k (mod p)) (mod q) */
-  mpz_powm(tmp, params->g, k, params->p);
+  mpz_powm_sec(tmp, params->g, k, params->p);
   mpz_fdiv_r(signature->r, tmp, params->q);
 
   /* Compute hash */
Index: nettle-3.2/rsa-blind.c
===================================================================
--- nettle-3.2.orig/rsa-blind.c	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/rsa-blind.c	2017-02-03 08:16:04.274825648 -0500
@@ -61,7 +61,7 @@
   while (!mpz_invert (ri, r, pub->n));
 
   /* c = c*(r^e) mod n */
-  mpz_powm(r, r, pub->e, pub->n);
+  mpz_powm_sec(r, r, pub->e, pub->n);
   mpz_mul(c, c, r);
   mpz_fdiv_r(c, c, pub->n);
 
Index: nettle-3.2/rsa-sign-tr.c
===================================================================
--- nettle-3.2.orig/rsa-sign-tr.c	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/rsa-sign-tr.c	2017-02-03 08:16:09.314886633 -0500
@@ -60,7 +60,7 @@
   while (!mpz_invert (ri, r, pub->n));
 
   /* c = c*(r^e) mod n */
-  mpz_powm(r, r, pub->e, pub->n);
+  mpz_powm_sec(r, r, pub->e, pub->n);
   mpz_mul(c, m, r);
   mpz_fdiv_r(c, c, pub->n);
 
@@ -88,6 +88,14 @@
   int res;
   mpz_t t, mb, xb, ri;
 
+  /* mpz_powm_sec handles only odd moduli. If p, q or n is even, the
+     key is invalid and rejected by rsa_private_key_prepare. However,
+     some applications, notably gnutls, don't use this function, and
+     we don't want an invalid key to lead to a crash down inside
+     mpz_powm_sec. So do an additional check here. */
+  if (mpz_even_p (pub->n) || mpz_even_p (key->p) || mpz_even_p (key->q))
+    return 0;
+
   mpz_init (mb);
   mpz_init (xb);
   mpz_init (ri);
@@ -97,7 +105,7 @@
 
   rsa_compute_root (key, xb, mb);
 
-  mpz_powm(t, xb, pub->e, pub->n);
+  mpz_powm_sec(t, xb, pub->e, pub->n);
   res = (mpz_cmp(mb, t) == 0);
 
   if (res)
Index: nettle-3.2/rsa-sign.c
===================================================================
--- nettle-3.2.orig/rsa-sign.c	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/rsa-sign.c	2017-02-03 08:16:04.278825697 -0500
@@ -96,11 +96,11 @@
 
   /* Compute xq = m^d % q = (m%q)^b % q */
   mpz_fdiv_r(xq, m, key->q);
-  mpz_powm(xq, xq, key->b, key->q);
+  mpz_powm_sec(xq, xq, key->b, key->q);
 
   /* Compute xp = m^d % p = (m%p)^a % p */
   mpz_fdiv_r(xp, m, key->p);
-  mpz_powm(xp, xp, key->a, key->p);
+  mpz_powm_sec(xp, xp, key->a, key->p);
 
   /* Set xp' = (xp - xq) c % p. */
   mpz_sub(xp, xp, xq);
Index: nettle-3.2/rsa.c
===================================================================
--- nettle-3.2.orig/rsa.c	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/rsa.c	2017-02-03 08:16:06.454852027 -0500
@@ -58,13 +58,18 @@
 }
 
 /* Computes the size, in octets, of a the modulo. Returns 0 if the
- * modulo is too small to be useful. */
-
+ * modulo is too small to be useful, or otherwise appears invalid. */
 size_t
 _rsa_check_size(mpz_t n)
 {
   /* Round upwards */
-  size_t size = (mpz_sizeinbase(n, 2) + 7) / 8;
+  size_t size;
+
+  /* Even moduli are invalid, and not supported by mpz_powm_sec. */
+  if (mpz_even_p (n))
+    return 0;
+
+  size = (mpz_sizeinbase(n, 2) + 7) / 8;
 
   if (size < RSA_MINIMUM_N_OCTETS)
     return 0;
Index: nettle-3.2/testsuite/rsa-test.c
===================================================================
--- nettle-3.2.orig/testsuite/rsa-test.c	2016-01-28 15:02:21.000000000 -0500
+++ nettle-3.2/testsuite/rsa-test.c	2017-02-03 08:16:06.454852027 -0500
@@ -57,6 +57,13 @@
 
   test_rsa_sha512(&pub, &key, expected);
 
+  /* Test detection of invalid keys with even modulo */
+  mpz_clrbit (pub.n, 0);
+  ASSERT (!rsa_public_key_prepare (&pub));
+
+  mpz_clrbit (key.p, 0);
+  ASSERT (!rsa_private_key_prepare (&key));
+
   /* 777-bit key, generated by
    *
    *   lsh-keygen -a rsa -l 777 -f advanced-hex
